// Generated by CoffeeScript 1.3.3
(function() {
  var ChallengeCompletedDetails, commands, debug, dictionary, mongo, paginator, repo, useDebug, winston, _;

  mongo = require('mongodb').MongoClient;

  _ = require('./myunderscore');

  commands = require('./commands');

  repo = require('./mongoRepository');

  paginator = require('./paginator');

  winston = require('winston');

  dictionary = require('./dictionarySchema');

  useDebug = true;

  debug = function(data) {
    if (useDebug) {
      return console.log(data);
    }
  };

  ChallengeCompletedDetails = (function() {

    function ChallengeCompletedDetails(RowKeyPrefix, userName, details) {
      this.RowKeyPrefix = RowKeyPrefix;
      this.userName = userName;
      this.details = details;
      this.created = new Date();
    }

    return ChallengeCompletedDetails;

  })();

  module.exports = {
    repo: repo,
    connect: function() {
      var _this = this;
      return mongo.connect('mongodb://localhost:27017/learnlocity', function(err, db) {
        if (err != null) {
          return console.dir(err);
        } else {
          debug('Got db:' + db);
          repo.setStorage(db);
          if (useDebug) {
            return repo.setDebugReporter = debug;
          }
        }
      });
    },
    find: function(query, done) {
      return repo.find(query, done);
    },
    paging: function(query) {
      return paginator.paging(query);
    },
    diffFilter: function(masterList, compareList, comparisonProperty, paging) {
      return paginator.diffFilter(masterList, compareList, comparisonProperty, paging);
    },
    userAuthenticate: function(login, callback) {
      var query;
      query = {
        from: 'AccountRegister',
        where: {
          $and: [
            {
              password: login.password
            }, {
              $or: [
                {
                  userName: login.userNameOrEmail
                }, {
                  email: login.userNameOrEmail
                }
              ]
            }
          ]
        },
        select: 'userName'
      };
      return this.find(query, function(users) {
        var exists;
        exists = users.length > 0;
        return callback(null, exists);
      });
    },
    challengeStateStore: function(challengeState, callback) {
      return repo.store(challengeState, challengeState.name, true, callback);
    },
    getQuestion: function(challengeState, index) {
      var answer, question;
      answer = challengeState.roundItems[index];
      question = new commands.ChallengeQuestion(challengeState.name, index, answer[0].definition, answer[1]);
      return question;
    },
    getAllQuestions: function(challengeState, includeAnswer) {
      var actualAnswer, answer, index, question, questions, _i, _len, _ref;
      if (includeAnswer == null) {
        includeAnswer = false;
      }
      questions = [];
      index = 0;
      _ref = challengeState.roundItems;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        answer = _ref[_i];
        actualAnswer = null;
        if (includeAnswer === true) {
          actualAnswer = answer[0].word;
        }
        question = new commands.ChallengeQuestion(challengeState.name, index, answer[0].definition, answer[1], actualAnswer);
        questions.push(question);
        index++;
      }
      return questions;
    },
    challengeJoinStore: function(challengeJoin, callback) {
      var rowKey, rowKeyPrefix;
      rowKeyPrefix = challengeJoin.name;
      rowKey = rowKeyPrefix + ":" + challengeJoin.userName;
      challengeJoin.RowKeyPrefix = rowKeyPrefix;
      return repo.store(challengeJoin, rowKey, false, callback);
    },
    challengeSubmitAnswerStore: function(challengeSubmitAnswer, callback) {
      var rowKey, rowKeyPrefix;
      rowKeyPrefix = challengeSubmitAnswer.name + ":" + challengeSubmitAnswer.userName;
      rowKey = rowKeyPrefix + ":" + challengeSubmitAnswer.index;
      challengeSubmitAnswer.RowKeyPrefix = rowKeyPrefix;
      return repo.store(challengeSubmitAnswer, rowKey, false, callback);
    },
    challengeAnswerScoredStore: function(challengeAnswerScored, callback) {
      var rowKey, rowKeyPrefix;
      rowKeyPrefix = challengeAnswerScored.name + ':' + challengeAnswerScored.userName;
      rowKey = rowKeyPrefix + ':' + challengeAnswerScored.index;
      challengeAnswerScored.RowKeyPrefix = rowKeyPrefix;
      return repo.store(challengeAnswerScored, rowKey, false, callback);
    },
    challengeCompletedDetailsStore: function(challengeCompletedDetails, callback) {
      var rowKey;
      rowKey = challengeCompletedDetails.name + ":" + challengeCompletedDetails.userName;
      return repo.store(challengeCompletedDetails, rowKey, false, callback);
    },
    findChallengeByName: function(name, callback) {
      var query;
      query = {
        from: 'ChallengeState',
        where: {
          name: name
        }
      };
      return this.find(query, function(challenges) {
        var challenge;
        challenge = null;
        if (challenges.length > 0) {
          challenge = challenges[0];
        }
        return callback(challenge);
      });
    },
    findChallengeJoinsByChallengeName: function(challengeName, callback) {
      var query;
      query = {
        from: 'ChallengeJoin',
        where: {
          name: challengeName
        }
      };
      return this.find(query, function(challengeJoins) {
        return callback(challengeJoins);
      });
    },
    userExistsAlready: function(accountRegistration, callback) {
      var query;
      query = {
        from: 'AccountRegister',
        where: {
          email: accountRegistration.email
        },
        select: 'userName'
      };
      return repo.find(query, function(users) {
        var exists;
        exists = users.length > 0;
        return callback(null, exists);
      });
    },
    challengesOpenFind: function(query, callback) {
      var paging,
        _this = this;
      paging = this.paging(query);
      return this.find({
        from: 'ChallengeState',
        select: ['name', 'userName', 'created'],
        sort: {
          created: -1
        }
      }, function(allChallenges) {
        return _this.find({
          from: 'ChallengeJoin',
          select: ['name'],
          where: {
            userName: query.userName
          }
        }, function(challengesJoined) {
          var challengesOpen;
          challengesOpen = _this.diffFilter(allChallenges, challengesJoined, 'name', paging);
          return callback(challengesOpen);
        });
      });
    },
    challengesActiveFind: function(query, callback) {
      var paging,
        _this = this;
      paging = this.paging(query);
      return this.find({
        from: 'ChallengeJoin',
        select: ['name', 'userName', 'created'],
        where: {
          userName: query.userName
        },
        sort: {
          created: -1
        }
      }, function(challengesJoined) {
        return _this.find({
          from: 'ChallengeCompletedDetails',
          select: ['details'],
          where: {
            userName: query.userName
          }
        }, function(challengesCompletedDetails) {
          var challengesActive, completedNames;
          completedNames = _.pluck(challengesCompletedDetails, 'name');
          challengesActive = _this.diffFilter(challengesJoined, completedNames, 'name', paging);
          return callback(challengesActive);
        });
      });
    },
    challengesCompletedFind: function(query, callback) {
      var paging,
        _this = this;
      paging = this.paging(query);
      return this.find({
        from: 'ChallengeCompletedDetails',
        select: ['name', 'details', 'created'],
        where: {
          userName: query.userName
        },
        sort: {
          created: -1
        }
      }, function(challengesCompletedDetails) {
        var result;
        challengesCompletedDetails = _.skipTake(challengesCompletedDetails, paging);
        result = paginator.createPagedResult(challengesCompletedDetails, paging);
        return callback(result);
      });
    },
    challengeScoreboardSummary: function(query, callback) {
      var paging,
        _this = this;
      query.limit = 20;
      paging = this.paging(query);
      return this.find({
        from: 'ChallengeCompletedDetails',
        select: ['name', 'userName', 'details', 'created'],
        sort: {
          created: -1
        }
      }, function(challengesCompletedDetails) {
        var challengeCompletedList, challengeName, group, groups, groupsUnsorted, result, sortedCompletedList, _i, _len;
        groupsUnsorted = _.groupBy(challengesCompletedDetails, function(challengeCompleted) {
          return challengeCompleted.details.name;
        });
        groups = [];
        for (challengeName in groupsUnsorted) {
          challengeCompletedList = groupsUnsorted[challengeName];
          sortedCompletedList = _.sortBy(challengeCompletedList, function(challengeCompleted) {
            return -challengeCompleted.details.answersCorrectCount;
          });
          groups.push(sortedCompletedList);
        }
        groups = _.sortBy(groups, function(group) {
          return -_.max(group, function(challengeCompleted) {
            return challengeCompleted.created;
          });
        });
        groups = _.skipTake(groups, paging);
        for (_i = 0, _len = groups.length; _i < _len; _i++) {
          group = groups[_i];
          group[0].latest = _.clone(_.max(group, function(challengeCompleted) {
            return challengeCompleted.created;
          }));
        }
        result = paginator.createPagedResult(groups, paging);
        return callback(result);
      });
    },
    scorePrefix: function(challenge, userName) {
      return challenge.name + ':' + userName;
    },
    challengeCompletedDetailsFind: function(challenge, userName, callback) {
      var keyPrefix,
        _this = this;
      keyPrefix = this.scorePrefix(challenge, userName);
      debug('Entering challengesCompletedFind:');
      debug(keyPrefix);
      return this.find({
        from: 'ChallengeAnswerScored',
        where: {
          RowKeyPrefix: keyPrefix
        }
      }, function(scoredAnswers) {
        var answersCorrectCount, challengeCompletedDetails, userChallengeCompletedDetails;
        answersCorrectCount = _.reduce(scoredAnswers, function(correctCount, answer) {
          if (answer.correct) {
            correctCount++;
          }
          return correctCount;
        }, 0);
        _.each(scoredAnswers, function(answer) {
          answer.word = challenge.roundItems[answer.index][0];
          return answer.choices = challenge.roundItems[answer.index][1];
        });
        userChallengeCompletedDetails = {
          name: challenge.name,
          userName: userName,
          answersCorrectCount: answersCorrectCount,
          answersAttemptCount: scoredAnswers.length,
          answersCorrectPercentage: (100 * (answersCorrectCount / scoredAnswers.length)).toFixed(0),
          answers: scoredAnswers
        };
        debug('here is the userChallengeCompletedDetails:');
        debug(userChallengeCompletedDetails);
        challengeCompletedDetails = new ChallengeCompletedDetails(keyPrefix, userName, userChallengeCompletedDetails);
        debug('and the actual challengeCompletedDetails:');
        debug(challengeCompletedDetails);
        return callback(challengeCompletedDetails);
      });
    },
    definitionsStore: function(definitions, callback) {
      return repo.store(definitions, 'Definitions', true, callback);
    },
    definitionsLoad: function(callback) {
      var _this = this;
      return this.find({
        from: 'Definitions'
      }, function(definitions) {
        return callback(definitions);
      });
    },
    definitionStore: function(definition, callback) {
      dictionary.findOne({
        title: definition.dictionary
      }, function(err, dictionary) {
        var word;
        if (dictionary != null) {
          word = {
            word: definition.word,
            definition: definition.definition
          };
          dictionary.words.push(word);
          return dictionary.save(function(err) {
            if (err != null) {
              return console.log('Error in definitionStore: ' + err);
            } else {
              return callback(err, word);
            }
          });
        }
      });
      return 'repo.storage.collection \'Definitions\', (err, collection) ->\n    collection.update {key:\'Definitions\'},\n        {$addToSet: {\'words\':definition}}, (err, result) ->\n            debug \'error: \' + err\n            debug \'res: \' + result\n            callback err, result';
    },
    dictionaryList: function(args, callback) {
      return dictionary.count({}, function(err, count) {
        var query;
        query = dictionary.find({});
        query.skip((args.page - 1) * 5);
        query.limit(5);
        return query.exec(function(err, dictionaryList) {
          var fakeList, items, result;
          items = _.map(dictionaryList, function(item) {
            return {
              title: item.title,
              wordCount: item.words.length
            };
          });
          fakeList = new Array(count);
          result = paginator.createPagedResult(fakeList, {
            limit: 5
          });
          result.items = items;
          console.log('result:');
          console.log(result);
          return callback(null, result);
        });
      });
    },
    dictionaryCreate: function(dictionaryCreateCmd, callback) {
      return dictionary.findOne({
        title: dictionaryCreateCmd.title
      }, function(err, existingDictionary) {
        var props;
        if (!(existingDictionary != null)) {
          props = {
            title: dictionaryCreateCmd.title,
            author: dictionaryCreateCmd.userName,
            words: []
          };
          console.log('props:');
          console.log(props);
          return dictionary.create(props, function(err, data) {
            console.log('err:');
            console.log(err);
            console.log('data:');
            console.log(data);
            if (!(err != null)) {
              return callback(null, {
                title: props.title
              });
            }
          });
        }
      });
    }
  };

}).call(this);
