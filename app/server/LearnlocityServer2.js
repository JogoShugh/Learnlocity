// Generated by CoffeeScript 1.3.3
(function() {
  var AccountRegister, Challenge, ChallengeAnswerScored, ChallengeCompletedDetails, ChallengeCreate, ChallengeJoin, ChallengePlayer, ChallengeQuestion, ChallengeQuestionByIndex, ChallengeResume, ChallengeScoreDetails, ChallengeScoreboard, ChallengeSendChatMessage, ChallengeSpy, ChallengeState, ChallengeStateFactory, ChallengeSubmitAnswer, ChallengeSubmitAnswerResponse, ChallengeWatch, ChallengesActive, ChallengesCompleted, ChallengesOpen, FACEBOOK_APP_ID, FACEBOOK_APP_SECRET, FacebookStrategy, LearnlocityServer, Login, NUMBER_OF_QUESTIONS_PER_ROUND, ScoreStatusInfo, app, debug, dict, express, http, importer, io, mongo, passport, server, storage, useDebug, users, _,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  importer = require('./importer');

  importer(require('./utils'));

  dict = require('./AgileDictionary');

  http = require('http');

  mongo = require('mongodb').MongoClient;

  storage = null;

  _ = require('underscore');

  _.mixin({
    skipTake: function(array, options) {
      options = _.extend({
        skip: 0,
        limit: 0
      }, options || {});
      return _(array).chain().rest(options.skip).first(options.limit || array.length - options.skip).value();
    }
  });

  mongo.connect('mongodb://localhost:27017/learnlocity', function(err, db) {
    if (err != null) {
      return console.dir(err);
    } else {
      console.log('Got db:' + db);
      return storage = db;
    }
  });

  NUMBER_OF_QUESTIONS_PER_ROUND = 3;

  useDebug = true;

  debug = function(data) {
    if (useDebug) {
      return console.log(data);
    }
  };

  AccountRegister = (function() {

    function AccountRegister(userName, email, password, passwordConfirm, id, externalAuth) {
      this.userName = userName != null ? userName : '';
      this.email = email != null ? email : '';
      this.password = password != null ? password : '';
      this.passwordConfirm = passwordConfirm != null ? passwordConfirm : '';
      this.id = id != null ? id : '';
      this.externalAuth = externalAuth != null ? externalAuth : false;
    }

    AccountRegister.prototype.getValidationErrors = function() {
      var sv;
      sv = new StringValidator;
      sv.field('userName', this.userName).max(50).min(4).notEmpty();
      if (this.externalAuth) {
        return sv.errors;
      }
      sv.field('email', this.email).max(100).min(5).notEmpty();
      sv.field('password', this.password).max(50).min(8).notEmpty();
      sv.field('Confirm Password', this.passwordConfirm).matches(this.password, 'Password');
      return sv.errors;
    };

    return AccountRegister;

  })();

  Login = (function() {

    function Login(userNameOrEmail, password, externalAuth) {
      this.userNameOrEmail = userNameOrEmail != null ? userNameOrEmail : '';
      this.password = password != null ? password : '';
      this.externalAuth = externalAuth != null ? externalAuth : false;
    }

    Login.prototype.getValidationErrors = function() {
      var sv;
      sv = new StringValidator;
      sv.field("Username or Email", this.userNameOrEmail).notEmpty().max(100).min(4);
      if (this.externalAuth) {
        return sv.errors;
      }
      sv.field("Password", this.password).notEmpty().max(50).min(8);
      return sv.errors;
    };

    return Login;

  })();

  ChallengesOpen = (function() {

    function ChallengesOpen(userName) {
      this.userName = userName;
    }

    return ChallengesOpen;

  })();

  ChallengesCompleted = (function() {

    function ChallengesCompleted(userName) {
      this.userName = userName;
    }

    return ChallengesCompleted;

  })();

  ChallengesActive = (function() {

    function ChallengesActive(userName) {
      this.userName = userName;
    }

    return ChallengesActive;

  })();

  ChallengeSendChatMessage = (function() {

    function ChallengeSendChatMessage(userName, message, dateTime) {
      this.userName = userName != null ? userName : "";
      this.message = message != null ? message : '';
      this.dateTime = dateTime != null ? dateTime : null;
    }

    return ChallengeSendChatMessage;

  })();

  ChallengeCreate = (function() {

    function ChallengeCreate(userName, name, isOpen, isGroup) {
      this.userName = userName != null ? userName : '';
      this.name = name != null ? name : '';
      this.isOpen = isOpen != null ? isOpen : false;
      this.isGroup = isGroup != null ? isGroup : false;
    }

    ChallengeCreate.prototype.getValidationErrors = function() {
      var sv;
      sv = new StringValidator;
      sv.field("Username", this.userName).notEmpty().max(50).min(4);
      sv.field("Name", this.name).notEmpty().max(50).min(5);
      return sv.errors;
    };

    return ChallengeCreate;

  })();

  ChallengeJoin = (function() {

    function ChallengeJoin(userName, name) {
      this.userName = userName != null ? userName : '';
      this.name = name != null ? name : '';
      this.created = new Date();
    }

    return ChallengeJoin;

  })();

  ChallengeResume = (function() {

    function ChallengeResume(userName, name) {
      this.userName = userName != null ? userName : '';
      this.name = name != null ? name : '';
    }

    return ChallengeResume;

  })();

  ChallengeSpy = (function() {

    function ChallengeSpy(userName, name) {
      this.userName = userName != null ? userName : '';
      this.name = name != null ? name : '';
    }

    return ChallengeSpy;

  })();

  ChallengeWatch = (function() {

    function ChallengeWatch(userName, name) {
      this.userName = userName != null ? userName : '';
      this.name = name != null ? name : '';
    }

    return ChallengeWatch;

  })();

  ChallengeQuestionByIndex = (function() {

    function ChallengeQuestionByIndex(name, index) {
      this.name = name != null ? name : '';
      this.index = index != null ? index : 0;
    }

    return ChallengeQuestionByIndex;

  })();

  ChallengeQuestion = (function() {

    function ChallengeQuestion(name, index, definition, choices, answer) {
      this.name = name != null ? name : '';
      this.index = index != null ? index : 0;
      this.definition = definition != null ? definition : '';
      this.choices = choices != null ? choices : [];
      if (answer != null) {
        this.answer = answer;
      }
    }

    return ChallengeQuestion;

  })();

  ChallengeSubmitAnswer = (function() {

    function ChallengeSubmitAnswer(name, userName, index, answer) {
      this.name = name != null ? name : '';
      this.userName = userName != null ? userName : '';
      this.index = index != null ? index : 0;
      this.answer = answer != null ? answer : '';
    }

    return ChallengeSubmitAnswer;

  })();

  ChallengeAnswerScored = (function() {

    function ChallengeAnswerScored(name, index, correct, userName) {
      this.name = name != null ? name : '';
      this.index = index != null ? index : 0;
      this.correct = correct != null ? correct : false;
      this.userName = userName != null ? userName : '';
      this.created = new Date();
    }

    return ChallengeAnswerScored;

  })();

  ChallengeSubmitAnswerResponse = (function() {

    function ChallengeSubmitAnswerResponse(challengeName, challengePlayerName, choice, result, scoreStatusInfo) {
      this.challengeName = challengeName != null ? challengeName : '';
      this.challengePlayerName = challengePlayerName != null ? challengePlayerName : '';
      this.choice = choice != null ? choice : '';
      this.result = result != null ? result : false;
      this.scoreStatusInfo = scoreStatusInfo != null ? scoreStatusInfo : null;
    }

    return ChallengeSubmitAnswerResponse;

  })();

  ScoreStatusInfo = (function() {

    function ScoreStatusInfo(answersAttemptCount, answersCorrectCount, answersPercentage, streakCount, streakIsCorrect) {
      this.answersAttemptCount = answersAttemptCount != null ? answersAttemptCount : 0;
      this.answersCorrectCount = answersCorrectCount != null ? answersCorrectCount : 0;
      this.answersPercentage = answersPercentage != null ? answersPercentage : 0.0;
      this.streakCount = streakCount != null ? streakCount : 0;
      this.streakIsCorrect = streakIsCorrect != null ? streakIsCorrect : false;
    }

    return ScoreStatusInfo;

  })();

  ChallengeCompletedDetails = (function() {

    function ChallengeCompletedDetails(RowKeyPrefix, userName, details) {
      this.RowKeyPrefix = RowKeyPrefix;
      this.userName = userName;
      this.details = details;
      this.created = new Date();
    }

    return ChallengeCompletedDetails;

  })();

  ChallengeScoreDetails = (function() {

    function ChallengeScoreDetails(name) {
      this.name = name;
    }

    return ChallengeScoreDetails;

  })();

  ChallengeScoreboard = (function() {

    function ChallengeScoreboard(userName) {
      this.userName = userName != null ? userName : '';
    }

    return ChallengeScoreboard;

  })();

  Challenge = (function() {

    function Challenge(userName, name) {
      this.userName = userName != null ? userName : '';
      this.name = name != null ? name : '';
      this._roundItems = [];
      this._players = [];
      this._wordsSeenAlready = [];
      this._generateRoundItems(NUMBER_OF_QUESTIONS_PER_ROUND);
      this.addPlayer(this.userName);
    }

    Challenge.prototype._randOrd = function() {
      return Math.round(Math.random()) - 0.5;
    };

    Challenge.prototype.addPlayer = function(userName) {
      return this._players.push([userName, new Array(NUMBER_OF_QUESTIONS_PER_ROUND)]);
    };

    Challenge.prototype._savePlayerAnswer = function(userName, index, answer, correct) {
      var p, player, _i, _len, _ref;
      player = null;
      _ref = this._players;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        if (p[0] === userName) {
          player = p;
        }
      }
      if (player != null) {
        return player[1][index] = {
          "answer": answer,
          "correct": correct
        };
      }
    };

    Challenge.prototype.questionByIndex = function(index) {
      return this._roundItems[index];
    };

    Challenge.prototype.submitAnswer = function(userName, index, answer) {
      var correct, question;
      if (index > this._roundItems.length) {
        return false;
      }
      question = this.questionByIndex(index);
      if (!(question != null)) {
        throw "Cannot submit answer for index: " + index;
      }
      correct = answer === question[0].word;
      this._savePlayerAnswer(userName, index, answer, correct);
      return correct;
    };

    Challenge.prototype.submitAnswer = function(userName, index, answer) {
      var correct, question;
      if (index > this._roundItems.length) {
        return false;
      }
      question = this.questionByIndex(index);
      if (!(question != null)) {
        throw "Cannot submit answer for index: " + index;
      }
      correct = answer === question[0].word;
      this._savePlayerAnswer(userName, index, answer, correct);
      return correct;
    };

    Challenge.prototype.scoreDetails = function() {
      return this._players;
    };

    Challenge.prototype._generateRoundItems = function(numberOfQuestions) {
      var choices, i, word, _i, _ref, _results;
      this._roundItems = [];
      _results = [];
      for (i = _i = 0, _ref = numberOfQuestions - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        word = this._getRandomUnseenWord();
        choices = this._getAnswerChoices(word).sort(this._randOrd);
        _results.push(this._roundItems.push([word, choices]));
      }
      return _results;
    };

    Challenge.prototype._getRandomUnseenWord = function() {
      var word;
      word = dict.Dictionary.getRandomWord();
      while (this._hasWordBeenSeenAlready(word)) {
        word = dict.Dictionary.getRandomWord();
      }
      return word;
    };

    Challenge.prototype._hasWordBeenSeenAlready = function(word) {
      return __indexOf.call(this._wordsSeenAlready, word) >= 0;
    };

    Challenge.prototype._registerSeenWord = function(word) {
      if (!_hasWordBeenSeenAlready(word)) {
        return this._wordsSeenAlready.push(word);
      }
    };

    Challenge.prototype._getAnswerChoices = function(currentWord) {
      var choices, i, word, _i;
      choices = [];
      for (i = _i = 0; _i <= 2; i = ++_i) {
        word = dict.Dictionary.getRandomWord();
        while (word === currentWord) {
          word = dict.Dictionary.getRandomWord();
        }
        choices.push(word.word);
      }
      choices.push(currentWord.word);
      return choices;
    };

    return Challenge;

  })();

  ChallengePlayer = (function() {

    function ChallengePlayer(userName) {
      this.userName = userName;
    }

    return ChallengePlayer;

  })();

  ChallengeState = (function() {

    function ChallengeState(userName, name, roundItems) {
      this.userName = userName;
      this.name = name;
      this.roundItems = roundItems;
      this.created = new Date();
    }

    return ChallengeState;

  })();

  ChallengeStateFactory = (function() {

    function ChallengeStateFactory() {}

    ChallengeStateFactory.prototype.create = function(userName, name) {
      var state;
      this.userName = userName != null ? userName : '';
      this.name = name != null ? name : '';
      this._roundItems = [];
      this._wordsSeenAlready = [];
      this._generateRoundItems(NUMBER_OF_QUESTIONS_PER_ROUND);
      state = new ChallengeState(this.userName, this.name, this._roundItems);
      return state;
    };

    ChallengeStateFactory.prototype._randOrd = function() {
      return Math.round(Math.random()) - 0.5;
    };

    ChallengeStateFactory.prototype._generateRoundItems = function(numberOfQuestions) {
      var choices, i, word, _i, _ref, _results;
      this._roundItems = [];
      _results = [];
      for (i = _i = 0, _ref = numberOfQuestions - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        word = this._getRandomUnseenWord();
        choices = this._getAnswerChoices(word).sort(this._randOrd);
        _results.push(this._roundItems.push([word, choices]));
      }
      return _results;
    };

    ChallengeStateFactory.prototype._getRandomUnseenWord = function() {
      var word;
      word = dict.Dictionary.getRandomWord();
      while (this._hasWordBeenSeenAlready(word)) {
        word = dict.Dictionary.getRandomWord();
      }
      return word;
    };

    ChallengeStateFactory.prototype._hasWordBeenSeenAlready = function(word) {
      return __indexOf.call(this._wordsSeenAlready, word) >= 0;
    };

    ChallengeStateFactory.prototype._getAnswerChoices = function(currentWord) {
      var choices, i, word, _i;
      choices = [];
      for (i = _i = 0; _i <= 2; i = ++_i) {
        word = dict.Dictionary.getRandomWord();
        while (word === currentWord) {
          word = dict.Dictionary.getRandomWord();
        }
        choices.push(word.word);
      }
      choices.push(currentWord.word);
      return choices;
    };

    return ChallengeStateFactory;

  })();

  LearnlocityServer = (function() {

    function LearnlocityServer() {
      this.ChallengeScoreboardAll = __bind(this.ChallengeScoreboardAll, this);

      this.ChallengeScoreboard = __bind(this.ChallengeScoreboard, this);

      this._challengeCompletedNotify = __bind(this._challengeCompletedNotify, this);

      this.ChallengeCreate = __bind(this.ChallengeCreate, this);

      this.ChallengesActive = __bind(this.ChallengesActive, this);

      this.ChallengesCompleted = __bind(this.ChallengesCompleted, this);

      this.ChallengesOpen = __bind(this.ChallengesOpen, this);

      this._find = __bind(this._find, this);

      this.Login = __bind(this.Login, this);

      this.AccountRegister = __bind(this.AccountRegister, this);
      this.NotifySourceClient = null;
      this.NotifyAllClients = null;
      this.Join = null;
      this.NotifyRoom = null;
      this._challenges = [];
      this._onlineMembers = [];
    }

    LearnlocityServer.prototype.send = function(cmd, callback) {
      return this[cmd.constructor.name](cmd, callback);
    };

    LearnlocityServer.prototype.invoke = function(commandName, cmd) {
      return this[commandName](cmd);
    };

    LearnlocityServer.prototype.AccountRegister = function(cmd, callback) {
      var errors,
        _this = this;
      if (callback == null) {
        callback = null;
      }
      errors = cmd.getValidationErrors();
      if (errors.length > 0) {
        this.NotifySourceClient("ErrorOccurred", errors);
        return;
      }
      return this._userExistsAlready(cmd, function(duplicateName) {
        if (duplicateName === true) {
          return _this.NotifySourceClient("ErrorOccurred", "Please try a different username. An account by that name already exists.");
        } else {
          return _this._store(cmd, cmd.username, false, function(err, user) {
            if (err != null) {
              return _this.NotifySourceClient("ErrorOccurred", err);
            } else {
              _this.NotifySourceClient("AccountRegisterSucceeded", cmd.userName);
              if (callback != null) {
                return callback();
              }
            }
          });
        }
      });
    };

    LearnlocityServer.prototype.Login = function(cmd, notifySourceClient) {
      var errors,
        _this = this;
      if (users[cmd.userNameOrEmail] != null) {
        cmd.externalAuth = true;
      }
      errors = cmd.getValidationErrors();
      if (errors.length > 0) {
        callback("ErrorOccurred", errors);
        return;
      }
      return this._userAuthenticate(cmd, function(err, authenticated) {
        var registerCmd, user;
        if (err != null) {
          debug("It blew up:" + err);
          notifySourceClient("ErrorOccurred", err);
        } else {
          if (authenticated) {
            _this._onlineMembers.push(cmd.userNameOrEmail);
            user = {
              userName: cmd.userNameOrEmail
            };
            if (cmd.externalAuth) {
              user.profile = users[cmd.userNameOrEmail];
            }
            return _this.NotifySourceClient('LoginSucceeded', user);
          } else {
            if (cmd.externalAuth) {
              registerCmd = new AccountRegister(cmd.userNameOrEmail, cmd.userNameOrEmail, cmd.userNameOrEmail, cmd.userNameOrEmail, "", true);
              return _this.AccountRegister(registerCmd, function() {
                return _this.NotifySourceClient("LoginSucceeded", cmd.userNameOrEmail);
              });
            } else {
              return _this.NotifySourceClient("LoginFailed", "Could not authenticate user with username or email of " + cmd.userNameOrEmail);
            }
          }
        }
      });
    };

    LearnlocityServer.prototype._find = function(query, done) {
      var collapseSelect, collection, field, findExec, keys, limit, select, skip, sort, values, where, _i, _len, _ref;
      skip = query.skip || 0;
      limit = query.limit || null;
      collection = storage.collection(query.from);
      sort = query.sort;
      values = [];
      where = query.where || {};
      select = null;
      collapseSelect = true;
      if (query.collapseSelect != null) {
        collapseSelect = query.collapseSelect;
      }
      if (query.select != null) {
        select = {};
        _ref = query.select;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          field = _ref[_i];
          select[field] = true;
        }
      } else {
        select = {};
      }
      keys = _.keys(select);
      findExec = collection.find(where, select).skip(skip);
      if (sort != null) {
        findExec = findExec.sort(sort);
      }
      if (limit != null) {
        findExec = findExec.limit(limit);
      }
      return findExec.stream().on('data', function(row) {
        var obj;
        obj = null;
        if (keys.length > 0) {
          obj = _.pick(row, keys);
        } else {
          obj = row;
        }
        return values.push(obj);
      }).on('end', function() {
        var key;
        if (collapseSelect === true && keys.length === 1) {
          key = keys[0];
          values = _.pluck(values, key);
        }
        if (done != null) {
          return done(values);
        }
      });
    };

    LearnlocityServer.prototype._paging = function(query) {
      var limit, page, skip;
      page = query.page || 1;
      limit = query.limit || 5;
      skip = (page - 1) * 5;
      return {
        page: page,
        limit: limit,
        skip: skip
      };
    };

    LearnlocityServer.prototype._pageCountCalc = function(list, pageSize) {
      var fractionalPages, itemCount, pageCount;
      pageCount = parseInt(list.length / pageSize);
      itemCount = list.length;
      fractionalPages = 0;
      if (list.length % pageSize > 0) {
        fractionalPages = 1;
      }
      pageCount += fractionalPages;
      return {
        pageCount: pageCount,
        itemCount: itemCount
      };
    };

    LearnlocityServer.prototype._diffFilter = function(masterList, compareList, comparisonProperty, paging) {
      var comparisonProperties, filteredList, pageInfo, result;
      comparisonProperties = _.pluck(masterList, comparisonProperty);
      filteredList = _.difference(comparisonProperties, compareList);
      pageInfo = this._pageCountCalc(filteredList, paging.limit);
      filteredList = _.skipTake(filteredList, paging);
      filteredList = _.filter(masterList, function(masterItem) {
        return _.contains(filteredList, masterItem[comparisonProperty]);
      });
      result = {
        items: filteredList,
        pageCount: pageInfo.pageCount,
        itemCount: pageInfo.itemCount
      };
      return result;
    };

    LearnlocityServer.prototype.ChallengesOpen = function(query) {
      var paging,
        _this = this;
      paging = this._paging(query);
      return this._find({
        from: 'ChallengeState',
        select: ['name', 'userName', 'created'],
        sort: {
          created: -1
        }
      }, function(allChallenges) {
        return _this._find({
          from: 'ChallengeJoin',
          select: ['name'],
          where: {
            userName: query.userName
          }
        }, function(challengesJoined) {
          var challengesNotJoined;
          challengesNotJoined = _this._diffFilter(allChallenges, challengesJoined, 'name', paging);
          return _this.NotifySourceClient('ChallengesOpenSent', challengesNotJoined);
        });
      });
    };

    LearnlocityServer.prototype.ChallengesCompleted = function(query) {
      var paging,
        _this = this;
      paging = this._paging(query);
      return this._find({
        from: 'ChallengeCompletedDetails',
        select: ['name', 'details', 'created'],
        where: {
          userName: query.userName
        },
        sort: {
          created: -1
        }
      }, function(challengesCompletedDetails) {
        var pageInfo, result;
        challengesCompletedDetails = _.skipTake(challengesCompletedDetails, paging);
        pageInfo = _this._pageCountCalc(challengesCompletedDetails, paging.limit);
        result = {
          items: challengesCompletedDetails,
          pageCount: pageInfo.pageCount,
          itemCount: pageInfo.itemCount
        };
        return _this.NotifySourceClient('ChallengesCompletedSent', result);
      });
    };

    LearnlocityServer.prototype.ChallengesActive = function(query) {
      var paging,
        _this = this;
      paging = this._paging(query);
      return this._find({
        from: 'ChallengeJoin',
        select: ['name', 'userName', 'created'],
        where: {
          userName: query.userName
        },
        sort: {
          created: -1
        }
      }, function(challengesJoined) {
        return _this._find({
          from: 'ChallengeCompletedDetails',
          select: ['details'],
          where: {
            userName: query.userName
          }
        }, function(challengesCompletedDetails) {
          var challengesActive, completedNames;
          completedNames = _.pluck(challengesCompletedDetails, 'name');
          challengesActive = _this._diffFilter(challengesJoined, completedNames, 'name', paging);
          return _this.NotifySourceClient('ChallengesActiveSent', challengesActive);
        });
      });
    };

    LearnlocityServer.prototype.ChallengeCreate = function(cmd) {
      var challengeState, errors, factory,
        _this = this;
      errors = cmd.getValidationErrors();
      console.log(errors);
      if (errors.length > 0) {
        return false;
      }
      factory = new ChallengeStateFactory();
      challengeState = factory.create(cmd.userName, cmd.name);
      console.log('factory: ' + factory);
      return this._challengeStateStore(challengeState, function(err, challengeName) {
        var challengeJoin;
        console.log('ChallengeCreate: ' + err);
        if (err != null) {
          debug("ChallengeCreate: " + err);
          return _this.NotifySourceClient("ErrorOccurred", err);
        } else {
          challengeJoin = new ChallengeJoin(cmd.userName, cmd.name);
          return _this._challengeJoinStore(challengeJoin, function(err, rowKey) {
            var questions;
            if (err != null) {
              debug("_challengeJoinStore:" + err);
              return _this.NotifySourceClient("ErrorOccurred", err);
            } else {
              debug("ChallengeCreate worked: " + challengeName);
              _this.Join(challengeName);
              _this.NotifySourceClient("ChallengeCreateSucceeded", challengeName);
              questions = _this._getAllQuestions(challengeState);
              _this.NotifySourceClient("ChallengeQuestionsSent", questions);
              return _this.NotifyAllClients("ChallengeCreated", {
                userName: challengeState.userName,
                name: challengeName,
                created: challengeState.created
              });
            }
          });
        }
      });
    };

    LearnlocityServer.prototype._challengeStateStore = function(challengeState, callback) {
      return this._store(challengeState, challengeState.name, true, callback);
    };

    LearnlocityServer.prototype._getQuestion = function(challengeState, index) {
      var answer, question;
      answer = challengeState.roundItems[index];
      question = new ChallengeQuestion(challengeState.name, index, answer[0].definition, answer[1]);
      return question;
    };

    LearnlocityServer.prototype._getAllQuestions = function(challengeState, includeAnswer) {
      var actualAnswer, answer, index, question, questions, _i, _len, _ref;
      if (includeAnswer == null) {
        includeAnswer = false;
      }
      questions = [];
      index = 0;
      _ref = challengeState.roundItems;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        answer = _ref[_i];
        actualAnswer = null;
        if (includeAnswer === true) {
          actualAnswer = answer[0].word;
        }
        question = new ChallengeQuestion(challengeState.name, index, answer[0].definition, answer[1], actualAnswer);
        questions.push(question);
        index++;
      }
      return questions;
    };

    LearnlocityServer.prototype.ChallengeJoin = function(cmd) {
      var _this = this;
      return this._findChallengeByName(cmd.name, function(challengeState) {
        var questions;
        if (challengeState != null) {
          _this.Join(challengeState.name);
          questions = _this._getAllQuestions(challengeState);
          _this.NotifySourceClient("ChallengeQuestionsSent", questions);
          return _this._challengeJoinStore(cmd, function(err, rowKey) {
            var challengeJoin;
            if (err != null) {
              debug("_challengeJoinStore:" + err);
              return _this.NotifySourceClient("ErrorOccurred", err);
            } else {
              challengeJoin = {
                name: cmd.name,
                userName: cmd.userName,
                message: "" + cmd.userName + " joined " + cmd.name + "!"
              };
              if ((users[cmd.userName] != null) && (users[cmd.userName].photos != null) && users[cmd.userName].photos.length > 0) {
                challengeJoin.userAvatarUrl = users[cmd.userName].photos[0].value;
              }
              _this.NotifyRoomChannels(challengeState.name, 'ChallengeJoined', challengeJoin);
              return _this._findChallengeJoinsByChallengeName(cmd.name, function(challengeJoins) {
                var _i, _len, _results;
                _results = [];
                for (_i = 0, _len = challengeJoins.length; _i < _len; _i++) {
                  challengeJoin = challengeJoins[_i];
                  if ((users[challengeJoin.userName] != null) && (users[challengeJoin.userName].photos != null) && users[challengeJoin.userName].photos.length > 0) {
                    challengeJoin.userAvatarUrl = users[challengeJoin.userName].photos[0].value;
                  }
                  challengeJoin.message = "" + challengeJoin.userName + " joined " + challengeJoin.name + "!";
                  _results.push(_this.NotifySourceClient('ChallengeJoined', challengeJoin));
                }
                return _results;
              });
            }
          });
        }
      });
    };

    LearnlocityServer.prototype.ChallengeResume = function(cmd) {
      var _this = this;
      return this._findChallengeByName(cmd.name, function(challengeState) {
        var challengeJoin, questions;
        if (challengeState != null) {
          _this.Join(challengeState.name);
          questions = _this._getAllQuestions(challengeState);
          _this.NotifySourceClient("ChallengeQuestionsSent", questions);
          challengeJoin = {
            name: cmd.name,
            userName: cmd.userName,
            message: "" + cmd.userName + " joined " + cmd.name + "!"
          };
          if ((users[cmd.userName] != null) && (users[cmd.userName].photos != null) && users[cmd.userName].photos.length > 0) {
            challengeJoin.userAvatarUrl = users[cmd.userName].photos[0].value;
          }
          _this.NotifySourceClient(challengeState.name, 'ChallengeJoined', challengeJoin);
          return _this._findChallengeJoinsByChallengeName(cmd.name, function(challengeJoins) {
            var findScorings, _i, _len;
            for (_i = 0, _len = challengeJoins.length; _i < _len; _i++) {
              challengeJoin = challengeJoins[_i];
              if ((users[challengeJoin.userName] != null) && (users[challengeJoin.userName].photos != null) && users[challengeJoin.userName].photos.length > 0) {
                challengeJoin.userAvatarUrl = users[challengeJoin.userName].photos[0].value;
              }
              challengeJoin.message = "" + challengeJoin.userName + " joined " + challengeJoin.name + "!";
              _this.NotifySourceClient('ChallengeJoined', challengeJoin);
            }
            findScorings = {
              from: 'ChallengeAnswerScored',
              where: {
                name: cmd.name
              },
              done: function(challengeAnswerScorings) {
                var challengeAnswerScored, _j, _len1, _results;
                _results = [];
                for (_j = 0, _len1 = challengeAnswerScorings.length; _j < _len1; _j++) {
                  challengeAnswerScored = challengeAnswerScorings[_j];
                  if (challengeAnswerScored.userName === !cmd.userName) {
                    delete challengeAnswerScored.answer;
                  }
                  _results.push(_this.NotifySourceClient('ChallengeAnswerScored', challengeAnswerScored, true));
                }
                return _results;
              }
            };
            return _this._find(findScorings);
          });
        }
      });
    };

    LearnlocityServer.prototype.ChallengeWatch = function(cmd) {
      var _this = this;
      return this._findChallengeByName(cmd.name, function(challengeState) {
        var questions;
        if (challengeState != null) {
          _this.Join(challengeState.name + 'Watch');
          questions = _this._getAllQuestions(challengeState, true);
          _this.NotifySourceClient("ChallengeQuestionsSent", questions);
          _this.NotifySourceClient("ChallengeWatched", {
            name: cmd.name
          });
          return _this._findChallengeJoinsByChallengeName(cmd.name, function(challengeJoins) {
            var challengeJoin, _i, _len, _results;
            _results = [];
            for (_i = 0, _len = challengeJoins.length; _i < _len; _i++) {
              challengeJoin = challengeJoins[_i];
              if ((users[challengeJoin.userName] != null) && (users[challengeJoin.userName].photos != null) && users[challengeJoin.userName].photos.length > 0) {
                challengeJoin.userAvatarUrl = users[challengeJoin.userName].photos[0].value;
              }
              challengeJoin.message = "" + challengeJoin.userName + " joined " + challengeJoin.name + "!";
              _results.push(_this.NotifySourceClient('ChallengeJoined', challengeJoin));
            }
            return _results;
          });
        }
      });
    };

    LearnlocityServer.prototype.ChallengeSpy = function(cmd) {
      var _this = this;
      return this._findChallengeByName(cmd.name, function(challengeState) {
        var questions;
        if (challengeState != null) {
          _this.Join(challengeState.name + 'Spy');
          questions = _this._getAllQuestions(challengeState, true);
          _this.NotifySourceClient("ChallengeQuestionsSent", questions);
          _this.NotifySourceClient("ChallengeSpied", {
            name: cmd.name
          });
          return _this._findChallengeJoinsByChallengeName(cmd.name, function(challengeJoins) {
            var challengeJoin, _i, _len, _results;
            _results = [];
            for (_i = 0, _len = challengeJoins.length; _i < _len; _i++) {
              challengeJoin = challengeJoins[_i];
              if ((users[challengeJoin.userName] != null) && (users[challengeJoin.userName].photos != null) && users[challengeJoin.userName].photos.length > 0) {
                challengeJoin.userAvatarUrl = users[challengeJoin.userName].photos[0].value;
              }
              challengeJoin.message = "" + challengeJoin.userName + " joined " + challengeJoin.name + "!";
              _results.push(_this.NotifySourceClient('ChallengeJoined', challengeJoin));
            }
            return _results;
          });
        }
      });
    };

    LearnlocityServer.prototype._challengeJoinStore = function(challengeJoin, callback) {
      var rowKey, rowKeyPrefix;
      rowKeyPrefix = challengeJoin.name;
      rowKey = rowKeyPrefix + ":" + challengeJoin.userName;
      challengeJoin.RowKeyPrefix = rowKeyPrefix;
      return this._store(challengeJoin, rowKey, false, callback);
    };

    LearnlocityServer.prototype.ChallengeSubmitAnswer = function(cmd) {
      var _this = this;
      return this._findChallengeByName(cmd.name, function(challenge) {
        if (challenge != null) {
          return _this._challengeSubmitAnswerStore(cmd, function(err, rowKey) {
            var challengeAnswerScored, challengeAnswerScoredSave, correct;
            if (err != null) {
              debug("ERROR: _challengeSubmitAnswer:" + err);
              return _this.NotifySourceClient("ErrorOccurred", err);
            } else {
              correct = _this._answerIsCorrect(cmd, challenge);
              challengeAnswerScored = new ChallengeAnswerScored(cmd.name, cmd.index, correct, cmd.userName);
              challengeAnswerScoredSave = new ChallengeAnswerScored(cmd.name, cmd.index, correct, cmd.userName);
              challengeAnswerScoredSave.answer = cmd.answer;
              return _this._challengeAnswerScoredStore(challengeAnswerScoredSave, function() {
                _this.NotifyRoomChannels(cmd.name, 'ChallengeAnswerScored', challengeAnswerScored, false, {
                  Spy: {
                    answer: cmd.answer
                  }
                });
                challengeAnswerScored.answer = cmd.answer;
                _this.NotifySourceClient('ChallengeAnswerScored', challengeAnswerScored);
                if (cmd.index === (NUMBER_OF_QUESTIONS_PER_ROUND - 1)) {
                  console.log("Completed the challenge now at index: " + cmd.index);
                  return _this._challengeCompletedNotify(challenge, cmd);
                }
              });
            }
          });
        }
      });
    };

    LearnlocityServer.prototype._challengeSubmitAnswerStore = function(challengeSubmitAnswer, callback) {
      var rowKey, rowKeyPrefix;
      rowKeyPrefix = challengeSubmitAnswer.name + ":" + challengeSubmitAnswer.userName;
      rowKey = rowKeyPrefix + ":" + challengeSubmitAnswer.index;
      debug("The key is: " + rowKey);
      challengeSubmitAnswer.RowKeyPrefix = rowKeyPrefix;
      return this._store(challengeSubmitAnswer, rowKey, false, callback);
    };

    LearnlocityServer.prototype._challengeAnswerScoredStore = function(challengeAnswerScored, callback) {
      var rowKey, rowKeyPrefix;
      rowKeyPrefix = challengeAnswerScored.name + ':' + challengeAnswerScored.userName;
      rowKey = rowKeyPrefix + ':' + challengeAnswerScored.index;
      challengeAnswerScored.RowKeyPrefix = rowKeyPrefix;
      return this._store(challengeAnswerScored, rowKey, false, callback);
    };

    LearnlocityServer.prototype._answerIsCorrect = function(challengeSubmitAnswer, challenge) {
      var answer, correct, index, selection;
      index = challengeSubmitAnswer.index;
      selection = challengeSubmitAnswer.answer;
      answer = challenge.roundItems[index];
      correct = false;
      if (selection === answer[0].word) {
        correct = true;
      }
      return correct;
    };

    LearnlocityServer.prototype._challengeCompletedNotify = function(challenge, challengeSubmitAnswer) {
      var answers, collection, completedUserName, keyPrefix, typeName,
        _this = this;
      typeName = "ChallengeAnswerScored";
      completedUserName = challengeSubmitAnswer.userName;
      keyPrefix = challengeSubmitAnswer.name + ':' + completedUserName;
      answers = [];
      collection = storage.collection(typeName);
      return collection.find({
        RowKeyPrefix: keyPrefix
      }).stream().on('data', function(item) {
        return answers.push(item);
      }).on('end', function() {
        var answersCorrectCount, challengeCompletedDetails, userChallengeCompletedDetails;
        answersCorrectCount = _.reduce(answers, function(correctCount, answer) {
          if (answer.correct) {
            correctCount++;
          }
          return correctCount;
        }, 0);
        _.each(answers, function(answer) {
          answer.word = challenge.roundItems[answer.index][0];
          return answer.choices = challenge.roundItems[answer.index][1];
        });
        userChallengeCompletedDetails = {
          name: challenge.name,
          userName: completedUserName,
          answersCorrectCount: answersCorrectCount,
          answersAttemptCount: answers.length,
          answersCorrectPercentage: (100 * (answersCorrectCount / answers.length)).toFixed(0),
          answers: answers
        };
        challengeCompletedDetails = new ChallengeCompletedDetails(keyPrefix, completedUserName, userChallengeCompletedDetails);
        return _this._challengeCompletedDetailsStore(challengeCompletedDetails, function() {
          console.log('Saved the challengeCompletedDetails successfully: ');
          console.log(challengeCompletedDetails);
          _this.NotifySourceClient('ChallengeCompletedDetails', challengeCompletedDetails);
          _this.Join(keyPrefix + 'Finished');
          return _this.ChallengeScoreboardAll({});
        });
      });
    };

    LearnlocityServer.prototype._challengeCompletedDetailsStore = function(challengeCompletedDetails, callback) {
      var rowKey;
      rowKey = challengeCompletedDetails.name + ":" + challengeCompletedDetails.userName;
      console.log('The rowKey for saving completedDetails: ' + rowKey);
      return this._store(challengeCompletedDetails, rowKey, false, callback);
    };

    LearnlocityServer.prototype.ChallengeScoreDetails = function(cmd) {
      var challenge;
      challenge = this._findChallengeByName(cmd.name);
      if (challenge != null) {
        return challenge.scoreDetails();
      }
      return null;
    };

    LearnlocityServer.prototype.ChallengeScoreboard = function(query) {
      var paging,
        _this = this;
      query.limit = 20;
      paging = this._paging(query);
      return this._find({
        from: 'ChallengeCompletedDetails',
        select: ['name', 'userName', 'details', 'created'],
        sort: {
          created: -1
        }
      }, function(challengesCompletedDetails) {
        var challengeCompletedList, challengeName, group, groups, groupsUnsorted, pageInfo, result, sortedCompletedList, _i, _len;
        groupsUnsorted = _.groupBy(challengesCompletedDetails, function(challengeCompleted) {
          return challengeCompleted.details.name;
        });
        groups = [];
        for (challengeName in groupsUnsorted) {
          challengeCompletedList = groupsUnsorted[challengeName];
          sortedCompletedList = _.sortBy(challengeCompletedList, function(challengeCompleted) {
            return -challengeCompleted.details.answersCorrectCount;
          });
          groups.push(sortedCompletedList);
        }
        groups = _.sortBy(groups, function(group) {
          return -_.max(group, function(challengeCompleted) {
            return challengeCompleted.created;
          });
        });
        pageInfo = _this._pageCountCalc(groups, paging.limit);
        groups = _.skipTake(groups, paging);
        for (_i = 0, _len = groups.length; _i < _len; _i++) {
          group = groups[_i];
          group[0].latest = _.clone(_.max(group, function(challengeCompleted) {
            return challengeCompleted.created;
          }));
        }
        result = {
          items: groups,
          pageCount: pageInfo.pageCount,
          itemCount: pageInfo.itemCount
        };
        return _this.NotifySourceClient('ChallengeScoreboardSent', result);
      });
    };

    LearnlocityServer.prototype.ChallengeScoreboardAll = function(query) {
      var paging,
        _this = this;
      query.limit = 20;
      paging = this._paging(query);
      return this._find({
        from: 'ChallengeCompletedDetails',
        select: ['name', 'userName', 'details', 'created'],
        sort: {
          created: -1
        }
      }, function(challengesCompletedDetails) {
        var challengeCompletedList, challengeName, group, groups, groupsUnsorted, pageInfo, result, sortedCompletedList, _i, _len;
        groupsUnsorted = _.groupBy(challengesCompletedDetails, function(challengeCompleted) {
          return challengeCompleted.details.name;
        });
        groups = [];
        for (challengeName in groupsUnsorted) {
          challengeCompletedList = groupsUnsorted[challengeName];
          sortedCompletedList = _.sortBy(challengeCompletedList, function(challengeCompleted) {
            return -challengeCompleted.details.answersCorrectCount;
          });
          groups.push(sortedCompletedList);
        }
        groups = _.sortBy(groups, function(group) {
          return -_.max(group, function(challengeCompleted) {
            return challengeCompleted.created;
          });
        });
        pageInfo = _this._pageCountCalc(groups, paging.limit);
        groups = _.skipTake(groups, paging);
        for (_i = 0, _len = groups.length; _i < _len; _i++) {
          group = groups[_i];
          group[0].latest = _.clone(_.max(group, function(challengeCompleted) {
            return challengeCompleted.created;
          }));
        }
        result = {
          items: groups,
          pageCount: pageInfo.pageCount,
          itemCount: pageInfo.itemCount
        };
        return _this.NotifyAllClients('ChallengeScoreboardSent', result);
      });
    };

    LearnlocityServer.prototype._findChallengeByName = function(name, callback) {
      var challengeState, collection, typeName;
      typeName = "ChallengeState";
      collection = storage.collection(typeName);
      challengeState = null;
      console.log("Challenge name: " + name);
      return collection.find({
        name: name
      }).stream().on('data', function(item) {
        return challengeState = item;
      }).on('end', function() {
        return callback(challengeState);
      });
    };

    LearnlocityServer.prototype._findChallengeJoinsByChallengeName = function(challengeName, callback) {
      var challengeJoins, collection, typeName;
      typeName = "ChallengeJoin";
      collection = storage.collection(typeName);
      challengeJoins = [];
      return collection.find({
        name: challengeName
      }).stream().on('data', function(item) {
        return challengeJoins.push(item);
      }).on('end', function() {
        return callback(challengeJoins);
      });
    };

    LearnlocityServer.prototype._userExistsAlready = function(accountRegistration, callback) {
      var collection, exists, typeName;
      typeName = "AccountRegister";
      collection = storage.collection(typeName);
      exists = false;
      return collection.find({
        email: accountRegistration.email
      }).stream().on('data', function(item) {
        debug('user exists');
        return exists = true;
      }).on('end', function() {
        debug("Exists: " + exists);
        return callback(exists);
      });
    };

    LearnlocityServer.prototype._userAuthenticate = function(login, callback) {
      var collection, exists, query, typeName;
      typeName = "AccountRegister";
      collection = storage.collection(typeName);
      exists = false;
      query = {
        $and: [
          {
            password: login.password
          }, {
            $or: [
              {
                userName: login.userNameOrEmail
              }, {
                email: login.userNameOrEmail
              }
            ]
          }
        ]
      };
      return collection.find(query).stream().on('data', function(row) {
        return exists = true;
      }).on('end', function() {
        return callback(null, exists);
      });
    };

    LearnlocityServer.prototype._store = function(obj, key, stringify, callback) {
      var typeName;
      typeName = obj.constructor.name;
      return storage.collection(typeName, function(err, collection) {
        if (err != null) {
          debug("ERROR: _store:collection: " + err);
          callback(err, null);
        } else {
          debug("typeName: " + typeName + ": " + key + ': ' + obj);
          obj.key = key;
          return collection.insert(obj, function(err, result) {
            if (err != null) {
              return callback(err, null);
            } else {
              return callback(null, key);
            }
          });
        }
      });
    };

    return LearnlocityServer;

  })();

  module.exports = {
    LearnlocityServer: LearnlocityServer,
    AccountRegister: AccountRegister,
    Login: Login,
    ChallengeScoreboard: ChallengeScoreboard,
    ChallengesOpen: ChallengesOpen,
    ChallengesCompleted: ChallengesCompleted,
    ChallengesActive: ChallengesActive,
    ChallengeCreate: ChallengeCreate,
    ChallengeJoin: ChallengeJoin,
    ChallengeResume: ChallengeResume,
    ChallengeWatch: ChallengeWatch,
    ChallengeSpy: ChallengeSpy,
    ChallengeQuestionByIndex: ChallengeQuestionByIndex,
    ChallengeSubmitAnswer: ChallengeSubmitAnswer,
    ChallengeScoreDetails: ChallengeScoreDetails
  };

  express = require('express');

  app = express();

  server = http.createServer(app);

  io = require('socket.io').listen(server);

  passport = require('passport');

  FacebookStrategy = require('passport-facebook').Strategy;

  FACEBOOK_APP_ID = '145122539006776';

  FACEBOOK_APP_SECRET = '94eb7e44b1945f31c2cbfb37dcf1f3ff';

  users = {};

  passport.use(new FacebookStrategy({
    clientID: FACEBOOK_APP_ID,
    clientSecret: FACEBOOK_APP_SECRET,
    callbackURL: 'http://localhost:8000/auth/facebook/callback',
    profileFields: ['id', 'displayName', 'username', 'photos', 'email', 'name', 'profileUrl']
  }, function(accessToken, refreshToken, profile, done) {
    console.log(profile);
    return done(null, profile);
  }));

  passport.serializeUser(function(user, done) {
    users[user.username] = user;
    return done(null, user.username);
  });

  passport.deserializeUser(function(id, done) {
    var user;
    user = users[id];
    return done(null, user);
  });

  app.configure(function() {
    app.use('/app', express["static"](__dirname + '/../'));
    app.use(passport.initialize());
    app.use(passport.session());
    return app.use(app.router);
  });

  app.get('/auth/facebook', passport.authenticate('facebook'));

  app.get('/auth/facebook/callback', passport.authenticate('facebook', {
    failureRedirect: '/auth/facebook'
  }), function(req, res) {
    console.log('res user:');
    console.log(req.user);
    console.log('-----');
    return res.redirect('/app/index.html#/?user=' + req.user.username);
  });

  server.listen(8000);

  io.sockets.on('connection', function(socket) {
    var join, learnlocityServer, notifyAllClients, notifyRoom, notifySourceClient, sourceClientId;
    console.log('started');
    learnlocityServer = new LearnlocityServer;
    sourceClientId = socket.id;
    notifyAllClients = function(topic, data) {
      return io.sockets.emit('message', [topic, data]);
    };
    notifySourceClient = function(topic, data) {
      return io.sockets.socket(sourceClientId).emit('message', [topic, data]);
    };
    join = function(room) {
      return socket.join(room);
    };
    notifyRoom = function(room, topic, data, includeSelf) {
      if (includeSelf == null) {
        includeSelf = false;
      }
      if (includeSelf) {
        return io.sockets["in"](room).emit('message', [topic, data]);
      } else {
        return socket.broadcast.to(room).emit('message', [topic, data]);
      }
    };
    learnlocityServer.NotifyAllClients = notifyAllClients;
    learnlocityServer.NotifySourceClient = notifySourceClient;
    learnlocityServer.Join = join;
    learnlocityServer.NotifyRoom = notifyRoom;
    learnlocityServer.NotifyRoomChannels = function(room, topic, data, includeSelf, mixInPropertiesMap) {
      var localData, subChannel, _i, _len, _ref, _results;
      if (includeSelf == null) {
        includeSelf = false;
      }
      if (mixInPropertiesMap == null) {
        mixInPropertiesMap = null;
      }
      this.NotifyRoom(room, topic, data, includeSelf);
      _ref = ['Watch', 'Spy'];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        subChannel = _ref[_i];
        localData = _.clone(data);
        if ((mixInPropertiesMap != null) && (mixInPropertiesMap[subChannel] != null)) {
          _.extend(localData, mixInPropertiesMap[subChannel]);
        }
        _results.push(this.NotifyRoom(room + subChannel, topic, localData, includeSelf));
      }
      return _results;
    };
    return socket.on('message', function(data) {
      var cmd, commandClassName, commandConstructorArguments, key, props, value;
      commandClassName = data[0];
      commandConstructorArguments = data[1];
      console.log('socket.on message: ' + commandClassName + " -> " + commandConstructorArguments);
      cmd = new module.exports[commandClassName];
      props = data[1];
      for (key in props) {
        value = props[key];
        cmd[key] = value;
      }
      debug(commandClassName + ", " + cmd);
      return learnlocityServer.invoke(commandClassName, cmd);
    });
  });

}).call(this);
