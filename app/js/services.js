// Generated by CoffeeScript 1.3.3
(function() {
  var ChallengeState, ScoreBoard;

  ChallengeState = (function() {

    function ChallengeState(socket, challengeName, creatorName) {
      var _this = this;
      this.socket = socket;
      this.challengeName = challengeName;
      this.currentChallengeQuestionIndex = 0;
      this.watchingOnly = true;
      this.spying = false;
      if (creatorName != null) {
        this.creatorName = creatorName;
      }
      this.scoreBoard = new ScoreBoard(this.socket, this.challengeName, this.creatorName);
      if (creatorName != null) {
        this.setWatchingOnly(false);
      }
      this.challengePlay = {
        hasAnswered: false,
        completed: false,
        challengeName: this.challengeName,
        isAnswered: function(player, index) {
          var answer;
          answer = player.answers[index];
          if (answer != null) {
            return answer.answered;
          } else {
            return false;
          }
        },
        getAnswerClass: function(player, index) {
          var answer, cssClass;
          answer = player.answers[index];
          cssClass = (answer != null ? 'label ' + (answer.correct ? 'label-success' : 'label-important') : '');
          return cssClass;
        },
        getUserAvatarUrl: function(playerName) {
          if (playerName === window.userName && (window.profile.photos != null) && window.profile.photos.length > 0) {
            return window.profile.photos[0].value;
          } else {
            return _this.scoreBoard.players[playerName].userAvatarUrl;
          }
        },
        hasUserAvatarUrl: function(playerName) {
          if (_this.scoreBoard.players[playerName].userAvatarUrl != null) {
            return true;
          }
          return playerName === window.userName && (window.profile.photos != null) && window.profile.photos.length;
        }
      };
    }

    ChallengeState.prototype.join = function(user) {
      this.scoreBoard.makeEmptyPlayerIfNotExist(user.userName);
      if (user.userAvatarUrl != null) {
        this.scoreBoard.players[user.userName].userAvatarUrl = user.userAvatarUrl;
      }
      if (user.userName === window.userName) {
        return this.setWatchingOnly(false);
      }
    };

    ChallengeState.prototype.setWatchingOnly = function(isWatchingOnly) {
      this.watchingOnly = isWatchingOnly;
      this.scoreBoard.watchingOnly = isWatchingOnly;
      return this.scoreBoard.updateDefinitionVisibility();
    };

    ChallengeState.prototype.setSpying = function(isSpying) {
      this.spying = isSpying;
      this.scoreBoard.spying = isSpying;
      this.scoreBoard.watchingOnly = false;
      return this.scoreBoard.updateDefinitionVisibility();
    };

    ChallengeState.prototype.setChallengeQuestions = function(challengeQuestions) {
      this.challengeQuestions = challengeQuestions;
      this.scoreBoard.setChallengeQuestions(challengeQuestions);
      this.scoreBoard.updateDefinitionVisibility();
      return this.challengePlay.questionCount = challengeQuestions.length;
    };

    ChallengeState.prototype.setCurrentQuestionIndex = function(challengeQuestion) {
      if (this.currentChallengeQuestionIndex < this.challengeQuestions.length) {
        return this.currentChallengeQuestionIndex = challengeQuestion.index;
      }
    };

    ChallengeState.prototype.sendNextQuestion = function() {
      var question;
      if (this.currentChallengeQuestionIndex < this.challengeQuestions.length) {
        question = this.challengeQuestions[this.currentChallengeQuestionIndex];
        this.socket.invoke('ChallengeQuestionSent', question);
        return this.currentChallengeQuestionIndex++;
      }
    };

    ChallengeState.prototype.applyQuestion = function(challengeQuestion) {
      var choices, definition, i, _i, _ref,
        _this = this;
      definition = challengeQuestion.definition;
      choices = challengeQuestion.choices;
      if (!this.watchingOnly) {
        this.scoreBoard.applyQuestionDefinition(challengeQuestion.index);
      }
      this.challengePlay.answerDefinition = challengeQuestion.definition;
      this.challengePlay.questionIndex = challengeQuestion.index + 1;
      for (i = _i = 0, _ref = challengeQuestion.choices.length; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.challengePlay['answer' + i] = challengeQuestion.choices[i];
      }
      return this.challengePlay.answer = function(index) {
        var answer, selection;
        selection = choices[index];
        answer = {
          name: challengeQuestion.name,
          index: challengeQuestion.index,
          answer: selection,
          userName: window.userName
        };
        _this.socket.send('ChallengeSubmitAnswer', answer);
        _this.scoreBoard.saveOwnAnswerSubmission(challengeQuestion.index, selection);
        return _this.sendNextQuestion();
      };
    };

    ChallengeState.prototype.updateScores = function(scoredAnswer) {
      this.scoreBoard.updateScores(scoredAnswer);
      if (scoredAnswer.userName === window.userName) {
        return this.challengePlay.hasAnswered = true;
      }
    };

    return ChallengeState;

  })();

  ScoreBoard = (function() {

    function ScoreBoard(socket, challengeName, creatorName) {
      this.socket = socket;
      this.challengeName = challengeName;
      this.creatorName = creatorName;
      this.watchingOnly = true;
      this.spying = false;
      this.summary = {
        playersCount: 0,
        answersCount: 0,
        answersCorrect: 0,
        answersAttempted: 0,
        percentCorrect: 0,
        points: 0,
        pointsPossible: 0
      };
      this.questions = [];
      this.players = {};
      this.lastResultClass = '';
      this.lastResultAnswer = '';
      this.answersCorrectCount = 0;
      this.answersAttemptCount = 0;
      this.answersCorrectPercentage = 0;
      if (this.creatorName != null) {
        this.makeEmptyPlayerIfNotExist(this.creatorName);
      }
    }

    ScoreBoard.prototype.makeEmptyPlayerIfNotExist = function(playerName) {
      if (!(this.players[playerName] != null)) {
        this.players[playerName] = {
          answersCorrectCount: 0,
          answersAttemptCount: 0,
          answersCorrectPercentage: 0,
          points: 0,
          answers: this.makeEmptyAnswers(3)
        };
        if (playerName === window.userName) {
          return this.players[playerName].answerSubmissions = [];
        }
      }
    };

    ScoreBoard.prototype.makeScoreBoardQuestions = function(challengeQuestions) {
      var challengeQuestion, question, questions, _i, _len;
      questions = [];
      for (_i = 0, _len = challengeQuestions.length; _i < _len; _i++) {
        challengeQuestion = challengeQuestions[_i];
        question = {
          definition: 'pending',
          answersCorrect: 0,
          answersAttempted: 0,
          percentCorrect: 0,
          points: 0
        };
        questions.push(question);
      }
      return questions;
    };

    ScoreBoard.prototype.makeEmptyAnswers = function(count) {
      var answers, i, _i, _ref;
      answers = [];
      for (i = _i = 0, _ref = count - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        answers.push({
          correct: false,
          answered: false,
          answer: '--------'
        });
      }
      return answers;
    };

    ScoreBoard.prototype.setChallengeQuestions = function(challengeQuestions) {
      this.challengeQuestions = challengeQuestions;
      return this.questions = this.makeScoreBoardQuestions(challengeQuestions);
    };

    ScoreBoard.prototype.applyQuestionDefinition = function(questionIndex) {
      if (this.questions[questionIndex] != null) {
        return this.questions[questionIndex].definition = this.challengeQuestions[questionIndex].definition;
      }
    };

    ScoreBoard.prototype.saveOwnAnswerSubmission = function(questionIndex, answer) {
      return this.players[window.userName].answerSubmissions[questionIndex] = answer;
    };

    ScoreBoard.prototype.updateIfOwnAnswer = function(scoredAnswer) {
      var labelFailure, labelSuccess;
      if (scoredAnswer.userName === window.userName) {
        labelSuccess = 'label label-success';
        labelFailure = 'label label-important';
        if (scoredAnswer.correct) {
          this.lastResultClass = labelSuccess;
        } else {
          this.lastResultClass = labelFailure;
        }
        return this.lastResultAnswer = scoredAnswer.answer;
      }
    };

    ScoreBoard.prototype.updateScores = function(scoredAnswer) {
      var answer, answersAttempted, answersCorrect, myScoredAnswer, player, playerAnswer, playerName, playerScores, question, questionIndex, totalAnswersAttempted, totalAnswersCorrect, totalPoints, _i, _len, _ref, _ref1, _ref2, _ref3;
      this.updateIfOwnAnswer(scoredAnswer);
      answer = this.players[scoredAnswer.userName].answers[scoredAnswer.index];
      if ((this.spying && scoredAnswer.answer) || (window.userName === scoredAnswer.userName)) {
        answer.answer = scoredAnswer.answer;
      }
      answer.correct = scoredAnswer.correct;
      answer.answered = true;
      if ((!this.spying) && (window.userName != null) && (this.players[window.userName] != null)) {
        myScoredAnswer = this.players[window.userName].answers[scoredAnswer.index];
        if (myScoredAnswer.answered) {
          _ref = this.players;
          for (playerName in _ref) {
            player = _ref[playerName];
            if (playerName !== window.userName) {
              playerAnswer = player.answers[scoredAnswer.index];
              if ((playerAnswer != null) && playerAnswer.correct && myScoredAnswer.correct) {
                playerAnswer.answer = myScoredAnswer.answer;
              }
            }
          }
        }
      }
      totalAnswersCorrect = 0;
      totalAnswersAttempted = 0;
      totalPoints = 0;
      playerScores = {};
      for (playerName in this.players) {
        playerScores[playerName] = {
          answersAttemptCount: 0,
          answersCorrectCount: 0
        };
      }
      _ref1 = this.questions;
      for (questionIndex = _i = 0, _len = _ref1.length; _i < _len; questionIndex = ++_i) {
        question = _ref1[questionIndex];
        answersCorrect = 0;
        answersAttempted = 0;
        _ref2 = this.players;
        for (playerName in _ref2) {
          player = _ref2[playerName];
          playerAnswer = player.answers[questionIndex];
          if (playerAnswer.answered) {
            answersAttempted++;
            playerScores[playerName].answersAttemptCount++;
            if (playerAnswer.correct) {
              answersCorrect++;
              playerScores[playerName].answersCorrectCount++;
            }
          }
        }
        this.updateDefinitionVisibility();
        question.points = answersCorrect * 100;
        question.answersCorrect = answersCorrect;
        question.answersAttempted = answersAttempted;
        totalAnswersCorrect += answersCorrect;
        totalAnswersAttempted += answersAttempted;
        totalPoints += question.points;
      }
      _ref3 = this.players;
      for (playerName in _ref3) {
        player = _ref3[playerName];
        player.answersAttemptCount = playerScores[playerName].answersAttemptCount;
        player.answersCorrectCount = playerScores[playerName].answersCorrectCount;
        player.points = player.answersCorrectCount * 100;
        if (playerName === window.userName) {
          this.answersCorrectCount = player.answersCorrectCount;
          this.answersAttemptCount = player.answersAttemptCount;
          if (player.answersCorrectCount > 0) {
            this.answersCorrectPercentage = (100 * (player.answersCorrectCount / player.answersAttemptCount)).toFixed(0);
          }
          this.points = player.points;
        }
      }
      this.summary.points = totalPoints;
      this.summary.answersCorrect = totalAnswersCorrect;
      return this.summary.answersAttempted = totalAnswersAttempted;
    };

    ScoreBoard.prototype.updateDefinitionVisibility = function() {
      var answersAttempted, player, playerAnswer, playerCount, playerName, question, questionIndex, _i, _len, _ref, _ref1, _results;
      _ref = this.questions;
      _results = [];
      for (questionIndex = _i = 0, _len = _ref.length; _i < _len; questionIndex = ++_i) {
        question = _ref[questionIndex];
        if (this.spying) {
          question.answer = this.challengeQuestions[questionIndex].answer;
        }
        answersAttempted = 0;
        playerCount = 0;
        _ref1 = this.players;
        for (playerName in _ref1) {
          player = _ref1[playerName];
          playerCount++;
          playerAnswer = player.answers[questionIndex];
          if (playerAnswer.answered) {
            answersAttempted++;
          }
        }
        console.log('answersattempted:' + answersAttempted);
        if (answersAttempted > 0 || this.spying) {
          if (answersAttempted >= playerCount || this.spying) {
            console.log('Applying definition now');
            this.applyQuestionDefinition(questionIndex);
            if (this.watchingOnly) {
              _results.push((function() {
                var _ref2, _results1;
                _ref2 = this.players;
                _results1 = [];
                for (playerName in _ref2) {
                  player = _ref2[playerName];
                  playerAnswer = player.answers[questionIndex];
                  if (playerAnswer.correct) {
                    _results1.push(playerAnswer.answer = this.challengeQuestions[questionIndex].answer);
                  } else {
                    _results1.push(void 0);
                  }
                }
                return _results1;
              }).call(this));
            } else {
              _results.push(void 0);
            }
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    ScoreBoard.prototype.getOwnAnswerSubmissionIfExists = function(questionIndex) {
      if ((this.players[window.userName] != null) && (this.players[window.userName].answerSubmissions != null)) {
        return this.players[window.userName].answerSubmissions[questionIndex];
      }
      return null;
    };

    return ScoreBoard;

  })();

  (function() {
    var app;
    app = angular.module('learnlocity.services', []).value('version', '0.1');
    app.service('socket', [
      '$rootScope', '$location', function($rootScope, $location) {
        var handlerDeregistrationCallbacks, socket, socketWrapper;
        socket = io.connect('http://localhost:8000');
        handlerDeregistrationCallbacks = [];
        socketWrapper = {
          on: function(topic, callback) {
            return socket.on(topic, function() {
              var args;
              args = arguments;
              return $rootScope.$apply(function() {
                return callback.apply(socket, args);
              });
            });
          },
          emit: function(topic, data, callback) {
            return socket.emit(topic, data, function() {
              var args;
              args = arguments;
              return $rootScope.$apply(function() {
                if (callback) {
                  return callback.apply(socket, args);
                }
              });
            });
          },
          send: function(topic, data) {
            console.log('send: ' + topic + ' -> ' + data);
            return this.emit('message', [topic, data]);
          },
          invoke: function(messageClassName, message) {
            console.log('recv: ' + messageClassName + ' -> ');
            console.log(message);
            return $rootScope.$broadcast(messageClassName, message);
          },
          handle: function(topic, handler) {
            var deregistrationCallback;
            deregistrationCallback = $rootScope.$on(topic, function(event, message) {
              return handler(message, $location, $rootScope);
            });
            return deregistrationCallback;
          }
        };
        return socketWrapper;
      }
    ]);
    app.factory('apiFactory', [
      '$rootScope', 'socket', function($rootScope, socket) {
        return function(scope) {
          var handlerDeregistrationCallbacks, obj;
          handlerDeregistrationCallbacks = {};
          scope.$on('$destroy', function() {
            var deregistrationCallback, responseTopicName, _results;
            _results = [];
            for (responseTopicName in handlerDeregistrationCallbacks) {
              deregistrationCallback = handlerDeregistrationCallbacks[responseTopicName];
              _results.push(deregistrationCallback());
            }
            return _results;
          });
          obj = {
            send: function(topic, data, handler, responseTopicName) {
              var deregistrationCallback;
              if (responseTopicName == null) {
                responseTopicName = '';
              }
              if (responseTopicName === '') {
                responseTopicName = topic + 'Complete';
              }
              if (!(handlerDeregistrationCallbacks[responseTopicName] != null)) {
                deregistrationCallback = socket.handle(responseTopicName, handler);
                handlerDeregistrationCallbacks[responseTopicName] = deregistrationCallback;
              }
              return socket.send(topic, data);
            }
          };
          return obj;
        };
      }
    ]);
    return app.run(function($rootScope, $location, socket) {
      var commandHandler, createChallenge, createChallengeFromJoin, getChallengeByName;
      $rootScope.challengesOpen = [];
      $rootScope.currentDefinition = $rootScope.activeChallenges = {};
      $rootScope.openChallenge = function(challengeName) {
        var activeChallenge;
        activeChallenge = $rootScope.activeChallenges[challengeName];
        if (activeChallenge != null) {
          return $location.path('/challengePlay').search({
            challengeName: challengeName
          });
        } else {
          return alert('You are not active in ' + challengeName);
        }
      };
      $rootScope.home = function() {
        return $location.path('/groupChallenge');
      };
      commandHandler = function(name, handler) {
        return $rootScope.$on(name, function(event, message) {
          console.log('Command handler: ' + name);
          console.log(message);
          return handler(message, $location, $rootScope);
        });
      };
      commandHandler('LoginSucceeded', function(message, $location, $rootScope) {
        window.userName = message.userName;
        $rootScope.loggedIn = true;
        $rootScope.loggedInUserName = message.userName;
        if (message.profile != null) {
          window.profile = message.profile;
        } else {
          window.profile = {};
        }
        return $location.path('/mainMenu');
      });
      commandHandler('ChallengesOpenSent', function(message, $location, $rootScope) {
        return $rootScope.challengesOpen = message;
      });
      commandHandler('ChallengeCreated', function(message) {
        return $rootScope.challengesOpen.items.unshift(message);
      });
      commandHandler('ChallengesActiveSent', function(message, $location, $rootScope) {
        return $rootScope.challengesActive = message;
      });
      commandHandler('ChallengesCompletedSent', function(message, $location, $rootScope) {
        return $rootScope.challengesCompleted = message;
      });
      commandHandler('ChallengeScoreboardSent', function(message, $location, $rootScope) {
        var item, _i, _len, _ref;
        _ref = message.items;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          item = _ref[_i];
          item.detailsVisible = false;
        }
        return $rootScope.scoreboard = message;
      });
      window.challenges = {};
      createChallenge = function(challengeName, creatorName) {
        if (window.challenges[challengeName] != null) {
          return window.challenges[challengeName];
        } else {
          window.challenges[challengeName] = new ChallengeState(socket, challengeName, creatorName);
        }
        return window.challenges[challengeName];
      };
      createChallengeFromJoin = function(challengeJoin) {
        var challengeName;
        challengeName = challengeJoin.name;
        if (window.challenges[challengeName] != null) {
          return window.challenges[challengeName];
        } else {
          window.challenges[challengeName] = new ChallengeState(socket, challengeName);
        }
        return window.challenges[challengeName];
      };
      getChallengeByName = function(challengeName) {
        return window.challenges[challengeName];
      };
      window.getChallengeByName = getChallengeByName;
      commandHandler('ChallengeCreateSucceeded', function(message, $location, $rootScope) {
        createChallenge(message, window.userName);
        return $rootScope.activeChallenges[message] = message;
      });
      commandHandler('ChallengeQuestionsSent', function(message, $location, $rootScope) {
        var challenge, challengeName;
        challengeName = message[0].name;
        challenge = getChallengeByName(challengeName);
        if (!(challenge != null)) {
          challenge = createChallenge(challengeName, null);
        }
        challenge.setChallengeQuestions(message);
        return $location.path('/challengePlay').search({
          challengeName: challengeName
        });
      });
      commandHandler('ChallengeQuestionSent', function(challengeQuestion, $location, $rootScope) {
        var challenge, challengeName;
        if (challengeQuestion) {
          challengeName = challengeQuestion.name;
          challenge = getChallengeByName(challengeName);
          return challenge.applyQuestion(challengeQuestion);
        }
      });
      commandHandler('ChallengeJoined', function(message, $location, $rootScope) {
        var challenge;
        challenge = getChallengeByName(message.name);
        if (challenge != null) {
          return challenge.join(message);
        } else {
          challenge = createChallengeFromJoin(message);
          challenge.join(message);
          if (message.userName === window.userName) {
            $rootScope.activeChallenges[message.name] = message.name;
          }
          return $location.path('/challengePlay').search({
            challengeName: message.name
          });
        }
      });
      commandHandler('ChallengeWatched', function(message) {
        var challenge;
        challenge = getChallengeByName(message.name);
        if (challenge != null) {
          return challenge.setWatchingOnly(true);
        }
      });
      commandHandler('ChallengeSpied', function(message) {
        var challenge;
        challenge = getChallengeByName(message.name);
        if (challenge != null) {
          return challenge.setSpying(true);
        }
      });
      commandHandler('ChallengeAnswerScored', function(message, $location, $rootScope) {
        var challenge, challengeName;
        challengeName = message.name;
        challenge = getChallengeByName(challengeName);
        return challenge.updateScores(message);
      });
      commandHandler('ChallengerTotalsUpdated', function(message, $location, $rootScope) {
        var challenge, challengeName, player;
        challengeName = message.name;
        challenge = getChallengeByName(challengeName);
        player = challenge.scoreBoard.players[message.userName];
        player.answersCorrectCount = message.answersCorrectCount;
        player.answersAttemptCount = message.answersAttemptCount;
        player.answersCorrectPercentage = message.answersCorrectPercentage;
        return player.points = player.answersCorrectCount * 100;
      });
      return commandHandler('ChallengeCompletedDetails', function(message, $location, $rootScope) {
        var challenge, challengeName;
        challengeName = message.details.name;
        challenge = getChallengeByName(challengeName);
        return challenge.challengePlay.completed = true;
      });
    });
  })();

}).call(this);
